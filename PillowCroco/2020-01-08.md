
## 2020.1.8 (수), DFS
- [ ] (Labyrinth) https://www.acmicpc.net/problem/3482
- [x] (N-Queens) https://leetcode.com/problems/n-queens/
- [ ] (Sum Root to Leaf Numbers) https://leetcode.com/problems/sum-root-to-leaf-numbers/
- [ ] (단지번호붙이기) https://www.acmicpc.net/problem/2667
- [ ] (안전영역) https://www.acmicpc.net/problem/2468
- [x] (빙산) https://www.acmicpc.net/problem/2573
---

### N-Queens
https://leetcode.com/problems/n-queens/

```C++

// backtracking
// starts filling from the first row, screening the candidates in the same column, and diagonal
// then gets the next available candidate recursively and reverts screening.
#include <iostream>
#include <vector>
#include <string>
using namespace std;

#define N 10

int d[5][2] = { {0,-1}, {0,1}, {1,-1},{1,0},{1,1} };

// starts with all zeros.
void solveNQueens_backtrack(vector<vector<string>>& sols, vector<string>& sol,
                            vector<vector<int>>& visited, int size, int row) {

	// check current row's candidate and get recursive
	for (int col = 0; col < size; col++) {
		string n = "";
		if (visited[row][col] == 0) {
			visited[row][col] = 1;
			for (int i = 0; i < size; i++) {
				if (i == col) n += "Q";
				else n += ".";
			}

			// screening
			for (int i = 0; i < 5; i++) {
				int nx = row;
				int ny = col;
				while (true) {
					nx += d[i][0];
					ny += d[i][1];
					if (nx < 0 || nx >= size || ny < 0 || ny >= size) {
						break;
					}
					visited[nx][ny] += 1;
				}
			}

			sol.push_back(n);


			// if row meets the last.
			if (size - 1 == row) {
				/*for (auto a : visited) {
					for (int i = 0; i < size; i++)
						cout << a[i];
					cout << endl;
				}
				cout << endl;*/
				sols.push_back(sol);
			}

			// next candidate
			else solveNQueens_backtrack(sols, sol, visited, size, row + 1);

			// backtrack
			sol.pop_back();

			// unscreening
			for (int i = 0; i < 5; i++) {
				int nx = row;
				int ny = col;
				while (true) {
					nx += d[i][0];
					ny += d[i][1];
					if (nx < 0 || nx >= size || ny < 0 || ny >= size) {
						break;
					}
					visited[nx][ny] -= 1;
				}
			}

			visited[row][col] -= 1;

		}
	}

}
class Solution {
public:
	vector<vector<string>> solveNQueens(int n) {
		vector<vector<string>> sols;
		vector<string> sol;
		vector<vector<int>> visited;
		for (int i = 0; i < n; i++) {
			vector<int> v(n, 0);
			visited.push_back(v);
		}

		solveNQueens_backtrack(sols, sol, visited, n, 0);

		return sols;
	}
};

```

---

### 빙산
https://www.acmicpc.net/problem/2573


```C++

```
