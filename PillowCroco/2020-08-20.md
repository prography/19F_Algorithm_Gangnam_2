## 8/20/목, 자유주제
자기 하고 싶은 문제 2개씩


```python
# 시간 단위는 분
if 도착시간 > 시작시간 :
    벌금 += math.ceiling((도착시간-시작시간) / 5) * 500


if not accepted and not explained :
    벌금 += 2000
```


- [ ] 미네랄
https://www.acmicpc.net/problem/2933
- [x] 달이 차오른다, 가자
https://www.acmicpc.net/problem/1194
- [x] 207. Course Schedule
https://leetcode.com/problems/course-schedule/
- [x] 120. Triangle
https://leetcode.com/problems/triangle/
- [ ]  Partition to K Equal Sum Subsets
https://leetcode.com/problems/partition-to-k-equal-sum-subsets/
- [ ] Maximum XOR of Two Numbers in an Array
https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/


---


### 미네랄
https://www.acmicpc.net/problem/2933



```c++
```

---
### 달이 차오른다, 가자
https://www.acmicpc.net/problem/1194

다 잘해놓고 최단거리 구하는걸 DFS로 해서 틀림 -.-

최단거리는 BFS가 가장 좋다. DFS로하면 backtrack해서 모든 경우를 다 찾아야함!




```c++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

#define endl '\n'
int d[5] = { -1, 0, 1, 0, -1 };
bool visited[1 << 6][50][50] { false };
char m[50][50];
int N, M;
// 쉬운거부터 생각하자.
// 열쇠, 문 다 없다 -> 출구까지 dfs 최단경로 구함.
// 열쇠, 문 한쌍만 있다 -> 출구 도달 가능한지 확인 후, 불가하면 열쇠부터 찾음
// 열쇠2, 문1 있다 -> 출구도달불가하면 열쇠 1

// 거리가 가까워지면 반드시 열 필요가 없는 문도 열어야할때가 있네
// 출구부터 거꾸로 해서 필요한 선행조건을 stack으로 쌓아보자
// F가 필요하다-> F, f 넣고. 쭉쭉..
// 문제는 동시에 집을 수 있는 애들이 나오면, 최단거리를 어떻게 계산하죠?

// 다시 쉽게 생각하자. 도달 가능한 지점의 거리를 구하고 weighted graph로 생각
// lowercase를 얻으면 uppercase가 .으로 바뀌도록 함.
// 1에 도달할수있든 없든 key를 얻고 가는 경우를 다 check해야함


// bfs로 구현, key를 얻으면 visited가 다시 갱신되어서 새로 탐색을 시작해야함
//

//벽과 키 없는 문은 false, 나머진 true
bool okToPass(int key, char c) {
	if (c >= 'A' && c <= 'F') {
		return key & (1 << c - 'A');
	}
	else if (c == '#')
		return false;
	else
		return true;
}

struct kxy {
public:
	int key;
	int x;
	int y;
	int dist;

	kxy(int key, int x, int y, int dist) : key(key), x(x), y(y), dist(dist) {};
};

int main() {
	//while (true) {
		vector<int> f_dist;
		int x, y;
		cin >> N >> M;
		cin.get(); // cin으로 받으려면 처음의 개행문자도 넘겨줌
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				m[i][j] = cin.get();
				if (m[i][j] == '0') {
					x = i;
					y = j;
				}
			}
			cin.get();
		}

		//cout << "............\n";
		//for (int i = 0; i < N; i++) {
		//	for (int j = 0; j < M; j++) {
		//		cout << m[i][j];
		//	}
		//	cout << endl;
		//}

		//cout << okToPass(8, 'A');
		visited[0][x][y] = true; // 이건 왜안해놨던거야
		queue<kxy> Q;
		Q.push(kxy(0, x, y, 0));
		while (!Q.empty()) {
			int key = Q.front().key;
			int x = Q.front().x;
			int y = Q.front().y;
			int dist = Q.front().dist;
			Q.pop();
			for (int i = 0; i < 4; i++) {
				int nx = x + d[i], ny = y + d[i + 1];
				if (nx >= 0 && nx < N && ny >= 0 && ny < M) {
					// 벽과 키 없는 문이 여기서 걸림
					if (!visited[key][nx][ny] && okToPass(key, m[nx][ny])) {
						// 새롭게 키를 획득
						if (m[nx][ny] >= 'a' && m[nx][ny] <= 'f'
							&& !(key & (1 << m[nx][ny] - 'a'))) {
							// 요 밑의 두개가 필요가 있을까?
							//visited[key][nx][ny] = true;
							//dfs(nx, ny, key, dist + 1, visited, f_dist);

							visited[key | (1 << m[nx][ny] - 'a')][nx][ny] = true;
							Q.push(kxy(key | (1 << m[nx][ny] - 'a'), nx, ny, dist + 1));						}
						// 도착지
						else if (m[nx][ny] == '1') // 왜 1로 쓰냐 ㅄ아 아휴
							f_dist.push_back(dist + 1);
						// . 이거나, 이미 먹은 키거나, 키를 가진 문
						else {
							visited[key][nx][ny] = true;
							Q.push(kxy(key, nx, ny, dist + 1));
						}
					}
				}
			}
		}
		if (f_dist.empty())
			cout << -1 << endl;

		else {
			int min = 2147483630;
			for (auto n : f_dist) {
				//cout << n << " ";
				min = min > n ? n : min;
			}
			cout << min << endl;
		}
	//}
	return 0;
}
```

---
### 207. Course Schedule
https://leetcode.com/problems/course-schedule/

위상정렬 뇌빼고 해도 되네;; 이게 왜 돌아가는지도 잘 모르겠는데 어쨋든 돌아감


```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int> > adj(numCourses, vector<int>());
        vector<int> indeg(numCourses,0);
        for(auto p: prerequisites){
            adj[p[1]].push_back(p[0]);
            indeg[p[0]]++;
        }

        int size = numCourses;

        queue<int> Q;
        for(int i=0; i<numCourses;i++){
            if(indeg[i] == 0){
                Q.push(i);
                size--;
            }
        }

        if(Q.empty())
            return false;

        while(!Q.empty()){
            int idx = Q.front(); Q.pop();
            for(int to: adj[idx]){
                indeg[to]--;
                if(indeg[to] == 0){
                    Q.push(to);
                    size--;
                }
            }
        }

        return size? false: true;
    }
};
```

---
### 120. Triangle
https://leetcode.com/problems/triangle/

O(n)으로 구현할수있는 방법도 있는데 귀찮음.

n만큼 만들어놓고 아래층부터 하ㅏ씩 삭삭 땡겨오면 되긴함.

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>> triangle) {
        if(triangle.empty())
            return NULL;

        if(triangle.size()==1)
            return triangle[0][0];

        for(int i=triangle.size()-2;i>=0;--i){
            for(int j=0;j<triangle[i].size();++j){
                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);
            }
        }
        return triangle[0][0];
    }
};

// 0->0,1 1->1,2, 5->5,6 : i->i,i+1
// 0->0, 0,1->1, 1,2->2, ... n-1, n->n, n->n+1
```

---
### Partition to K Equal Sum Subsets
https://leetcode.com/problems/partition-to-k-equal-sum-subsets/



```c++
```

---
### Maximum XOR of Two Numbers in an Array
https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/


```c++
```

---
