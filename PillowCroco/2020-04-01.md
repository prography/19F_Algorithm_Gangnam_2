## 2020.4.1 (수), 실전 문제(SWEA 테스트 기출 + solved.ac 실버 이상)

- [x] https://www.acmicpc.net/problem/3190
- [ ] https://www.acmicpc.net/problem/14499
- [x] https://www.acmicpc.net/problem/1992
- [ ] https://www.acmicpc.net/problem/17140
- [ ] https://www.acmicpc.net/problem/14501
- [x] https://www.acmicpc.net/problem/2470


---

### 뱀

```Python
import sys
import math


def snake_game(m, turns):
    dirr = {0: [-1, 0], 1: [0, 1], 2: [1, 0], 3: [0, -1]}
    i, j = 0, 0
    sec = 0
    d = 1
    n = len(m)

    q = [(0, 0)]
    while turns:
        t, xd = turns.pop(0)
        for _ in range(sec, t):
            i += dirr[d][0]
            j += dirr[d][1]

            # out of bounds
            if i < 0 or i >= n or j < 0 or j >= n:
                return sec + 1

            # touching its own body -- 어떻게 꼬리 방향을 설정하지?, apple 먹을때마다 q에 tail 좌표를 기록해보자
            if m[i][j] == 2:
                return sec + 1

            # empty
            if m[i][j] == 0:
                sec += 1
                tx, ty = q.pop(0)
                m[tx][ty] = 0
                m[i][j] = 2
                q.append((i, j))

            # yummy
            if m[i][j] == 1:
                sec += 1
                m[i][j] = 2
                q.append((i, j))

        # turn right
        if xd == "D":
            d = (d + 1) % 4
        # turn left
        else:
            d = (d + 3) % 4


if __name__ == "__main__":

    n = int(input())
    k = int(input())

    # empty takes "0"
    g = [[0 for _ in range(n)] for _ in range(n)]

    # apple takes "1"
    for _ in range(k):
        x, y = list(map(int, sys.stdin.readline().split()))
        g[x - 1][y - 1] = 1

    # snake takes "2"
    g[0][0] = 2

    l = int(input())
    turns = []

    # 해당 초에 이동을 마치고 회전한다. 아니 이런 기본적인 정보도 안줍니까?
    for _ in range(l):
        t, d = sys.stdin.readline().split()
        turns.append((int(t), d))

    turns.append((100000, "D"))
    print(snake_game(g, turns))

```


---

## 쿼드트리

```Python
def quad_tree(m, s):
    if len(m) == 1:
        return s + m[0][0]

    half = len(m) // 2
    full = len(m)
    q1 = [[m[i][j] for j in range(0, half)] for i in range(0, half)]
    q2 = [[m[i][j] for j in range(half, full)] for i in range(0, half)]
    q3 = [[m[i][j] for j in range(0, half)] for i in range(half, full)]
    q4 = [[m[i][j] for j in range(half, full)] for i in range(half, full)]

    if q1 == q2 == q3 == q4:
        return s + q1[0][0]

    s += "("
    s = quad_tree(q1, s)
    s = quad_tree(q2, s)
    s = quad_tree(q3, s)
    s = quad_tree(q4, s)
    s += ")"
    return s


if __name__ == "__main__":
    n = int(input())
    m = []

    for _ in range(n):
        m.append(list(input()))
    print(quad_tree(m, ''))

"""
64
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000100000000000000000000000000000
0000000000000000000000000000000001000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000010000000000000000000000
0000000000000000000000000000000000000000010000000000000000000000
0000000000000000000000000000000000000001111110000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000010000000000000000000000000000000
0000000000000000000000000000000000110000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000111000000000000000000000000000000000000000
0000000000000000000000011000000000000000000000000000000000000000
0000000000000000000000001000000000000000000000000000000000000000
0000000000000000000000001100000000000000000000000000000000000000
0000000000000000000000001110000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000001000000000000000000000000000
0000000000000000000000000000000000010100000000000000000000000000
0000000000000000000000000000000000001000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000

4
1010
0000
1010
0000

이런 케이스에서 문제가 생겼다

"""
# print("(0((((00(0001)(1000))000)0(00(00(0010)0)(0(0100)00))((00(0101)0)0((1100)(1100)00)((1000)000)))0(((0(1100)00)000)000)0)(000((000(0(1101)00))(00((1010)0(1011)0)0)0(((1100)(1000)00)000)))(00(00((000(0001))(00(1001)0)0((1000)000))0)0))")
```

---

### 두 용액
https://www.acmicpc.net/problem/2470

```Python

import sys

n = int(input())
s = list(map(int, sys.stdin.readline().split()))

# ans = [2000000001, 0, 0]
# for i in range(len(s)):
#     for j in range(i + 1, len(s)):
#         if abs(s[i] + s[j]) < ans[0]:
#             ans = [abs(s[i] + s[j]), s[i], s[j]]
#
# print(min(ans[1], ans[2]), max(ans[1], ans[2]))

# 당연하게도 시간초과남.. n^2이 아닌 더 좋은 방법을 찾아야함

s.sort()
# print(s)
l, r = 0, len(s) - 1
ans = [s[l]+s[r], s[l], s[r]]
while l < r - 1:
    if s[l]+s[r] < 0:
        l += 1
        ans = [s[l]+s[r], s[l], s[r]] if abs(s[l]+s[r]) < abs(ans[0]) else ans

    elif s[l]+s[r] > 0:
        r -= 1
        ans = [s[l]+s[r], s[l], s[r]] if abs(s[l]+s[r]) < abs(ans[0]) else ans
    else:
        break

print(ans[1], ans[2])

# -150 -20 -5 -3 5 20 25 99
```
