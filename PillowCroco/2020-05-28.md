## 5/21/목, SWEA 모의 SW 2개씩
모여서 각자 2개씩 랜덤하게 설명하기

```python
if 테스트fail and fail원인분석실패 :
    한문제당 2천원 벌금!지각하면 5분당 500원!
```

- [x] 2048(easy)
https://www.acmicpc.net/problem/12100
- [ ] 톱니바퀴
https://www.acmicpc.net/problem/14891
- [ ] 수영장
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpFQaAQMDFAUq&categoryId=AV5PpFQaAQMDFAUq&categoryType=CODE
- [ ] 원자소멸시뮬레이션
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRFInKex8DFAUo&categoryId=AWXRFInKex8DFAUo&categoryType=CODE
- [ ] 파이프 옮기기1
https://www.acmicpc.net/problem/17070

- [ ] 색종이 붙이기
https://www.acmicpc.net/problem/17136


---


### 2048(easy)
시간 너무 잡아먹었따.. empty cnt를 제대로 못해서 틀림 ㅠㅠ 바보다.

삼성은 brute force의 천국! 4^5개의 동작에 대해 다 해보고 max값을 뱉도록 했다. 이게 최선인가?
```c++
#include <iostream>
using namespace std;


void print(int** board, int n) {

	cout << "------------------" << endl;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cout << board[i][j] << " ";
		}
		cout << endl;
	}
}

//move, merge, move
void move(int** board, int n, int arrow) {
	switch (arrow) {
	case 0: // left
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = 0; j < n; j++) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j - empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}

			//print(board, n);
			//merge
			for (int j = 0; j < n - empty_cnt - 1; j++) {
				if (board[i][j] == board[i][j + 1]) {
					board[i][j] *= 2;
					board[i][j + 1] = 0;
					j++;
				}
			}
			//print(board, n);

			empty_cnt = 0;
			//move again
			for (int j = 0; j < n; j++) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j - empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}
			//print(board, n);
		}
		break;
	case 1: // right
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = n-1; j >=0 ; j--) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j + empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}

			//merge
			for (int j = n-1; j > empty_cnt; j--) {
				if (board[i][j] == board[i][j - 1]) {
					board[i][j] *= 2;
					board[i][j - 1] = 0;
					j--;
				}
			}

			empty_cnt = 0;
			//move again
			for (int j = n - 1; j >= 0; j--) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j + empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}
		}
		break;
	case 2: // up
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = 0; j < n; j++) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j - empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}

			//merge
			for (int j = 0; j < n - empty_cnt - 1; j++) {
				if (board[j][i] == board[j + 1][i]) {
					board[j][i] *= 2;
					board[j + 1][i] = 0;
					j++;
				}
			}

			empty_cnt = 0;
			//move again
			for (int j = 0; j < n; j++) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j - empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}
		}
		break;
	case 3: // down
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = n - 1; j >= 0; j--) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j + empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}

			//merge
			for (int j = n - 1; j > empty_cnt; j--) {
				if (board[j][i] == board[j - 1][i]) {
					board[j][i] *= 2;
					board[j - 1][i] = 0;
					j--;
				}
			}

			empty_cnt = 0;
			//move again
			for (int j = n - 1; j >= 0; j--) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j + empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}
		}
		break;
	}
}

void undo(int** board, int** ex_board, int n) {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			board[i][j] = ex_board[i][j];
		}
	}
}

void execute(int** board, int idx, int n, int& max) {
	if (idx == 0) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				max = (board[i][j]>max) ? board[i][j] : max;
			}
		}

		return;
	}

	int** ex_board = new int* [n];
	for (int i = 0; i < n; i++) {
		ex_board[i] = new int[n];
		for (int j = 0; j < n; j++) {
			ex_board[i][j] = board[i][j];
		}
	}

	move(board, n, 0);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);

	move(board, n, 1);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);

	move(board, n, 2);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);

	move(board, n, 3);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);


	for (int i = 0; i < n; i++) {
		delete[] ex_board[n - i - 1];
	}
	delete[] ex_board;
}

int main() {
	int n;
	cin >> n;
	int** board = new int* [n];
	for (int i = 0; i < n; i++) {
		board[i] = new int[n];
		for (int j = 0; j < n; j++) {
			cin >> board[i][j];
		}
	}

	/*move(board, n, 3);
	print(board, n);*/
	int max = 0;
	execute(board, 5, n, max);

	cout << max << endl;
	for (int i = 0; i < n; i++) {
		delete[] board[n - i - 1];
	}
	delete[] board;
	return 0;
}
```

---

### 톱니바퀴

```c++
```

---
