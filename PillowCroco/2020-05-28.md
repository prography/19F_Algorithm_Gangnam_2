## 5/21/목, SWEA 모의 SW 2개씩
모여서 각자 2개씩 랜덤하게 설명하기

```python
if 테스트fail and fail원인분석실패 :
    한문제당 2천원 벌금!지각하면 5분당 500원!
```

- [x] 2048(easy)
https://www.acmicpc.net/problem/12100
- [x] 톱니바퀴
https://www.acmicpc.net/problem/14891
- [ ] 수영장
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpFQaAQMDFAUq&categoryId=AV5PpFQaAQMDFAUq&categoryType=CODE
- [ ] 원자소멸시뮬레이션
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRFInKex8DFAUo&categoryId=AWXRFInKex8DFAUo&categoryType=CODE
- [ ] 파이프 옮기기1
https://www.acmicpc.net/problem/17070

- [ ] 색종이 붙이기
https://www.acmicpc.net/problem/17136


---


### 2048(easy)
시간 너무 잡아먹었따.. empty cnt를 제대로 못해서 틀림 ㅠㅠ 바보다.

삼성은 brute force의 천국! 4^5개의 동작에 대해 다 해보고 max값을 뱉도록 했다. 이게 최선인가?

```c++
#include <iostream>
using namespace std;


void print(int** board, int n) {

	cout << "------------------" << endl;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cout << board[i][j] << " ";
		}
		cout << endl;
	}
}

//move, merge, move
void move(int** board, int n, int arrow) {
	switch (arrow) {
	case 0: // left
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = 0; j < n; j++) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j - empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}

			//print(board, n);
			//merge
			for (int j = 0; j < n - empty_cnt - 1; j++) {
				if (board[i][j] == board[i][j + 1]) {
					board[i][j] *= 2;
					board[i][j + 1] = 0;
					j++;
				}
			}
			//print(board, n);

			empty_cnt = 0;
			//move again
			for (int j = 0; j < n; j++) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j - empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}
			//print(board, n);
		}
		break;
	case 1: // right
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = n-1; j >=0 ; j--) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j + empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}

			//merge
			for (int j = n-1; j > empty_cnt; j--) {
				if (board[i][j] == board[i][j - 1]) {
					board[i][j] *= 2;
					board[i][j - 1] = 0;
					j--;
				}
			}

			empty_cnt = 0;
			//move again
			for (int j = n - 1; j >= 0; j--) {
				if (board[i][j] != 0) {
					if (empty_cnt) {
						board[i][j + empty_cnt] = board[i][j];
						board[i][j] = 0;
					}
				}
				else empty_cnt++;
			}
		}
		break;
	case 2: // up
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = 0; j < n; j++) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j - empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}

			//merge
			for (int j = 0; j < n - empty_cnt - 1; j++) {
				if (board[j][i] == board[j + 1][i]) {
					board[j][i] *= 2;
					board[j + 1][i] = 0;
					j++;
				}
			}

			empty_cnt = 0;
			//move again
			for (int j = 0; j < n; j++) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j - empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}
		}
		break;
	case 3: // down
		for (int i = 0; i < n; i++) {
			int empty_cnt = 0;

			//move
			for (int j = n - 1; j >= 0; j--) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j + empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}

			//merge
			for (int j = n - 1; j > empty_cnt; j--) {
				if (board[j][i] == board[j - 1][i]) {
					board[j][i] *= 2;
					board[j - 1][i] = 0;
					j--;
				}
			}

			empty_cnt = 0;
			//move again
			for (int j = n - 1; j >= 0; j--) {
				if (board[j][i] != 0) {
					if (empty_cnt) {
						board[j + empty_cnt][i] = board[j][i];
						board[j][i] = 0;
					}
				}
				else empty_cnt++;
			}
		}
		break;
	}
}

void undo(int** board, int** ex_board, int n) {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			board[i][j] = ex_board[i][j];
		}
	}
}

void execute(int** board, int idx, int n, int& max) {
	if (idx == 0) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				max = (board[i][j]>max) ? board[i][j] : max;
			}
		}

		return;
	}

	int** ex_board = new int* [n];
	for (int i = 0; i < n; i++) {
		ex_board[i] = new int[n];
		for (int j = 0; j < n; j++) {
			ex_board[i][j] = board[i][j];
		}
	}

	move(board, n, 0);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);

	move(board, n, 1);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);

	move(board, n, 2);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);

	move(board, n, 3);
	execute(board, idx - 1, n, max);
	undo(board, ex_board, n);


	for (int i = 0; i < n; i++) {
		delete[] ex_board[n - i - 1];
	}
	delete[] ex_board;
}

int main() {
	int n;
	cin >> n;
	int** board = new int* [n];
	for (int i = 0; i < n; i++) {
		board[i] = new int[n];
		for (int j = 0; j < n; j++) {
			cin >> board[i][j];
		}
	}

	/*move(board, n, 3);
	print(board, n);*/
	int max = 0;
	execute(board, 5, n, max);

	cout << max << endl;
	for (int i = 0; i < n; i++) {
		delete[] board[n - i - 1];
	}
	delete[] board;
	return 0;
}
```

---

### 톱니바퀴

```c++
#include <iostream>
#include <cmath>
using namespace std;


inline int west(int* gear, int select) {
	return (gear[select] >> 1) & 1;
}

inline int east(int* gear, int select) {
	return (gear[select] >> 5) & 1;
}

void checker(int* gear, int select, bool* check, int lr = 0) {
	check[select] = true;

	/* for 1~3 gear, check right */
	if (select < 3 && lr >= 0) {
		if (east(gear, select) ^ west(gear, select + 1)) {
			checker(gear, select + 1, check, 1);
		}
	}

	/* for 2~4 gear, check left */
	if (select > 0 && lr <= 0) {
		if (east(gear, select - 1) ^ west(gear, select)) {
			checker(gear, select - 1, check, -1);
		}
	}

}
void rotation(int* gear, int select, int dir, bool* check) {
	for (int i = 0; i < 4; i++) {
		if (check[i]) {

			/* same direction */
			if ((i-select)%2 == 0) {

				/* clockwise == right shift */
				if (dir == 1) {
					int tmp = gear[i] & 1;
					gear[i] >>= 1;
					gear[i] += (tmp << 7);
				}

				/* counterclockwise == left shift */
				else {
					int tmp = (gear[i] >> 7) & 1;
					gear[i] <<= 1;
					gear[i] &= 255; // for 8bit.
					gear[i] += tmp;
				}
			}

			/* counter direction */
			else {

				/* clockwise == right shift */
				if (dir == -1) {
					int tmp = gear[i] & 1;
					gear[i] >>= 1;
					gear[i] += (tmp << 7);
				}

				/* counterclockwise == left shift */
				else {
					int tmp = (gear[i] >> 7) & 1;
					gear[i] <<= 1;
					gear[i] &= 255; // for 8bit.
					gear[i] += tmp;
				}
			}
		}
	}
}

void printgear(int* gear) {
	for (int j = 0; j < 4; j++) {
		for (int k = 0; k < 8; k++) {
			cout << ((gear[j]>>(7-k)) & 1);
		}
		cout << "(" << gear[j] << ")" << endl;
	}
}

int main() {
	int gear[4];

	/*
	10001011은 128+8+2+1로 표현할거임.
	만약 128보다 크면(12시가 N이면) 점수 획득.
	*/
	for (int i = 0; i < 4; i++) {
		cin >> gear[i];

		int tmp = 0;
		for (int j = 0; j < 8; j++) {
			tmp += (gear[i] % 10) * (int)pow(2, j);
			gear[i] /= 10;
		}
		gear[i] = tmp;
	}

	//printgear(gear);

	int k;
	cin >> k;

	int select;
	int dir;

	/* rotation */
	for (int i = 0; i < k; i++) {
		cin >> select;
		cin >> dir;
		bool check[4]{ false };
		checker(gear, select - 1, check);

		//cout << "------------------" << endl;
		//cout << check[0] << check[1] << check[2] << check[3] << endl;
		rotation(gear, select - 1, dir, check);
		//printgear(gear);
		//cout << "------------------" << endl;
	}


	/* score */
	int score = 0;
	for (int i = 0; i < 4; i++) {
		//cout << gear[i] << " ";
		score += (gear[i]>>7 & 1) * (int)pow(2, i);
	}
	//cout << endl;
	cout << score << endl;
	return 0;
}
```

---

### 수영장

```c++
```

---
