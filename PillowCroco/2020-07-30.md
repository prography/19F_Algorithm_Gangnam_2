## 7/30/목, 자유주제
자기 하고 싶은 문제 2개씩(2주 밀림)


```python
# 시간 단위는 분
if 도착시간 > 시작시간 :
    벌금 += math.ceiling((도착시간-시작시간) / 5)


if 테스트fail and fail원인분석실패 :
    벌금 += 2000
```


- [ ] 박성원
https://www.acmicpc.net/problem/1086
- [x] 큐빙
https://www.acmicpc.net/problem/5373
- [ ] word break
https://leetcode.com/problems/word-break/
- [x] gas station
https://leetcode.com/problems/gas-station/
- [ ] 지민이의 테러 Season II
https://www.acmicpc.net/problem/1650
- [ ] 알고스팟어
https://www.acmicpc.net/problem/2848
- [ ] 점심 식사시간
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl&categoryId=AV5-BEE6AK0DFAVl&categoryType=CODE
- [ ] Sum Root to Leaf Numbers
https://leetcode.com/problems/sum-root-to-leaf-numbers/
- [x] Number of Islands
https://leetcode.com/problems/number-of-islands/

---


### 박성원
https://www.acmicpc.net/problem/1086

```c++
```

---

###큐빙
https://www.acmicpc.net/problem/5373

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;


void top_changes(string& top, const char dir) {
	if (dir == '-') {
		char tmp1 = top[0], tmp2 = top[1];
		top[0] = top[2];
		top[1] = top[5];
		top[2] = top[8];
		top[5] = top[7];
		top[8] = top[6];
		top[7] = top[3];
		top[6] = tmp1;
		top[3] = tmp2;
	}

	else if (dir == '+') {
		char tmp1 = top[0], tmp2 = top[3];
		top[0] = top[6];
		top[3] = top[7];
		top[6] = top[8];
		top[7] = top[5];
		top[8] = top[2];
		top[5] = top[1];
		top[2] = tmp1;
		top[1] = tmp2;
	}
}

/* side에는 반시계로 넣어줍니다 */
void side_changes(vector<char*>& side, const char dir) {
	if (dir == '+') {
		char tmp1 = *side[0], tmp2 = *side[1], tmp3 = *side[2];
		for (int i = 0; i < 9; i++) {
			*side[i] = *side[i + 3];
		}
		*side[9] = tmp1;
		*side[10] = tmp2;
		*side[11] = tmp3;
	}

	else if (dir == '-') {
		// 얘도 0,1,2 저장하는게 아니고
		char tmp1 = *side[11], tmp2 = *side[10], tmp3 = *side[9];

		// 이거 계속 실수하네 방향 반대되면 물려 돌아가는 방향도 반대가 돼야 해
		//for (int i = 0; i < 9; i++)가 아니고
		for (int i = 11; i > 2; i--) {
			*side[i] = *side[i - 3];
		}
		*side[2] = tmp1;
		*side[1] = tmp2;
		*side[0] = tmp3;
	}
}

/* 9+4*3 CHANGES FOR EVERY ROTATION */
/* 옆면 변화가 매우매우 귀찮으므로.. */
/* 모든 회전하는 면을 윗면으로 올려준다음, 돌려주고 다시 원래대로 바꿔놓자! */
/* 는 더 어렵다 걍 노가다가 낫다. */
void rotation(string* cube, string way) {

	vector<char*> side;
	if(way[0] == 'U'){
		top_changes(cube[0], way[1]);
		side.push_back(&cube[1][0]);
		side.push_back(&cube[1][1]);
		side.push_back(&cube[1][2]);

		side.push_back(&cube[2][0]);
		side.push_back(&cube[2][1]);
		side.push_back(&cube[2][2]);

		side.push_back(&cube[3][0]);
		side.push_back(&cube[3][1]);
		side.push_back(&cube[3][2]);

		side.push_back(&cube[4][0]);
		side.push_back(&cube[4][1]);
		side.push_back(&cube[4][2]);
	}
	else if (way[0] == 'F') {
		top_changes(cube[1], way[1]);
		side.push_back(&cube[2][6]);
		side.push_back(&cube[2][3]);
		side.push_back(&cube[2][0]);


		side.push_back(&cube[0][8]);
		side.push_back(&cube[0][7]);
		side.push_back(&cube[0][6]);

		side.push_back(&cube[4][2]);
		side.push_back(&cube[4][5]);
		side.push_back(&cube[4][8]);

		side.push_back(&cube[5][0]);
		side.push_back(&cube[5][1]);
		side.push_back(&cube[5][2]);
	}
	else if (way[0] == 'R') {
		top_changes(cube[2], way[1]);
		side.push_back(&cube[3][6]);
		side.push_back(&cube[3][3]);
		side.push_back(&cube[3][0]);

		side.push_back(&cube[0][2]);
		side.push_back(&cube[0][5]);
		side.push_back(&cube[0][8]);

		side.push_back(&cube[1][2]);
		side.push_back(&cube[1][5]);
		side.push_back(&cube[1][8]);

		side.push_back(&cube[5][2]);
		side.push_back(&cube[5][5]);
		side.push_back(&cube[5][8]);
	}
	else if (way[0] == 'B') {
		top_changes(cube[3], way[1]);
		side.push_back(&cube[4][6]);
		side.push_back(&cube[4][3]);
		side.push_back(&cube[4][0]);

		side.push_back(&cube[0][0]);
		side.push_back(&cube[0][1]);
		side.push_back(&cube[0][2]);

		side.push_back(&cube[2][2]);
		side.push_back(&cube[2][5]);
		side.push_back(&cube[2][8]);

		side.push_back(&cube[5][8]);
		side.push_back(&cube[5][7]);
		side.push_back(&cube[5][6]);
	}
	else if (way[0] == 'L') {
		top_changes(cube[4], way[1]);
		side.push_back(&cube[1][6]);
		side.push_back(&cube[1][3]);
		side.push_back(&cube[1][0]);

		side.push_back(&cube[0][6]);
		side.push_back(&cube[0][3]);
		side.push_back(&cube[0][0]);

		side.push_back(&cube[3][2]);
		side.push_back(&cube[3][5]);
		side.push_back(&cube[3][8]);

		side.push_back(&cube[5][6]);
		side.push_back(&cube[5][3]);
		side.push_back(&cube[5][0]);
	}
	else if (way[0] == 'D') {
		top_changes(cube[5], way[1]);
		side.push_back(&cube[4][8]);
		side.push_back(&cube[4][7]);
		side.push_back(&cube[4][6]);

		side.push_back(&cube[3][8]);
		side.push_back(&cube[3][7]);
		side.push_back(&cube[3][6]);

		side.push_back(&cube[2][8]);
		side.push_back(&cube[2][7]);
		side.push_back(&cube[2][6]);

		side.push_back(&cube[1][8]);
		side.push_back(&cube[1][7]);
		side.push_back(&cube[1][6]);
	}

	side_changes(side, way[1]);
	side.clear();
}

// for check validity.
void print_cube(string* cube) {
	for (int i = 1; i <= 9; i++) {
		if (i % 3 == 1)
			cout << "    ";
		cout << cube[0][i - 1];
		if (i % 3 == 0)
			cout << endl;
	}
	cout << endl;


	for (int i = 0; i < 3; i++) {
		cout << cube[4][3 * i] << cube[4][3 * i + 1] << cube[4][3 * i + 2] << " ";
		cout << cube[1][3 * i] << cube[1][3 * i + 1] << cube[1][3 * i + 2] << " ";
		cout << cube[2][3 * i] << cube[2][3 * i + 1] << cube[2][3 * i + 2] << " ";
		cout << cube[3][3 * i] << cube[3][3 * i + 1] << cube[3][3 * i + 2] << " ";
		cout << endl;
	}
	cout << endl;

	for (int i = 1; i <= 9; i++) {
		if (i % 3 == 1)
			cout << "    ";
		cout << cube[5][i - 1];
		if (i % 3 == 0)
			cout << endl;
	}
	cout << endl;
}

int main() {
	int n_test;
	cin >> n_test;
	while (n_test--) {
		/* 위(w), 앞(r), 오른(b), 뒤(o), 왼(g), 아래(y)*/
		string cube[6] = { "wwwwwwwww", "rrrrrrrrr", "bbbbbbbbb",
						  "ooooooooo", "ggggggggg", "yyyyyyyyy" };
		int n;
		cin >> n;
		string way;
		while(n--){
			cin >> way;
			rotation(cube, way);

			//print_cube(cube);
		}

		for (int i = 1; i <= 9; i++) {
			cout << cube[0][i - 1];
			if (i % 3 == 0)
				cout << endl;
		}


	}

	return 0;
}
```

---

### word break
https://leetcode.com/problems/word-break/

```c++

```

---

###gas station
https://leetcode.com/problems/gas-station/

뭔가 매우... 매우 멍청하게 푼 것 같다.
sliding window로 풀었는데 완료조건에서 헤매서
여기저기에 조건문을 때려박았다.

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int l=0, r=1, gas_sum = gas[l], cost_sum = cost[l];
        if(gas.size() == 1)
            return gas[0]>=cost[0] ? 0 : -1;

        while(true){
            while(gas_sum<cost_sum){
                gas_sum -= gas[l];
                cost_sum -= cost[l];
                l++;
                if(l>=gas.size())
                    return -1;

                if(l==r){
                    gas_sum = gas[l];
                    cost_sum = cost[l];
                    r = (r+1)%gas.size();
                }
            }
            gas_sum += gas[r];
            cost_sum += cost[r];

            r = (r+1) % gas.size();

            if(l == r && gas_sum >= cost_sum )
                return l;
        }
    }
};
```

단 1가지 답만 존재한다는 것을 알기에, gas랑 cost가 같은 단위인 것을 생각하면 다음과 같이 좀더 예쁘게 짤 수 있겠다.

우선 `total += gas[i] - cost[i]`로 간단하게 한다.
증명은 좀 이따가 하기로 한다.. 잠좀자자..

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int total(0), subsum(INT_MAX), start(0);
        for(int i = 0; i < n; ++i){
            total += gas[i] - cost[i];
            if(total < subsum) {
                subsum = total;
                start = i + 1;
            }
        }
        return (total < 0) ?  -1 : (start%n);
    }
};
```

---

### 지민이의 테러 Season II
https://www.acmicpc.net/problem/1650

```c++
```

---

### 알고스팟어
https://www.acmicpc.net/problem/2848

```c++
```

---

### 점심 식사시간
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl&categoryId=AV5-BEE6AK0DFAVl&categoryType=CODE

```c++
```

---

### Sum Root to Leaf Numbers
https://leetcode.com/problems/sum-root-to-leaf-numbers/

```c++
```

---

### Number of Islands
https://leetcode.com/problems/number-of-islands/

`dfs` 안에 `dir[i][0]` ,`dir[i][1]`을 `dir[0][0]` ,`dir[0][1]`으로 쓰는 짓을 함 ㅎㅎ;;


```c++
int dir[4][2] = { {1,0},{0,1},{-1,0},{0,-1} };
void dfs(int r, int c, vector<vector<char>>& grid, vector<vector<bool>>& visited) {
    int R = grid.size(), C = grid[0].size();
    for (int i = 0; i < 4; i++) {
        int nr = r + dir[i][0];
        int nc = c + dir[i][1];

        if (nr < 0 || nr >= R || nc < 0 || nc >= C)
            continue;

        if (visited[nr][nc])
            continue;

        if (grid[nr][nc] == '0')
            continue;

        visited[nr][nc] = true;
        dfs(nr, nc, grid, visited);
    }
}

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty())
            return 0;

        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));

        int R = grid.size(), C = grid[0].size();
        int n = 0;
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                if (visited[i][j] ==false && grid[i][j] == '1') {
                    visited[i][j] = true;
                    n++;
                    dfs(i, j, grid, visited);


                    //for (int i = 0; i < 4; i++) {
                    //    for (int j = 0; j < 5; j++) {
                    //        cout << grid[i][j] << " ";
                    //    }
                    //    cout << endl;
                    //}

                    //cout << endl;
                    //for (int i = 0; i < 4; i++) {
                    //    for (int j = 0; j < 5; j++) {
                    //        cout << visited[i][j] << " ";
                    //    }
                    //    cout << endl;
                    //}

                    //cout << "--------------------------------------" << endl;
                }
            }
        }

        return n;
    }
};
```

---
