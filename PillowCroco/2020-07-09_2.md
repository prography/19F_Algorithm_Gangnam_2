## 7/9/목, 새시작 2
자기 하고 싶은 문제 2개씩


```python
# 시간 단위는 분
if 도착시간 > 시작시간 :
    벌금 += math.ceiling((도착시간-시작시간) / 5)


if 테스트fail and fail원인분석실패 :
    벌금 += 2000
```


- [ ] Coin Change
https://leetcode.com/problems/coin-change/
- [x] Jump Game
https://leetcode.com/problems/jump-game/
- [ ] 타임머신
https://www.acmicpc.net/problem/11657
- [ ] 임계경로
https://www.acmicpc.net/problem/1948
- [x] Permutation Sequence
https://leetcode.com/problems/permutation-sequence/
- [x] Add and Search Word
https://leetcode.com/problems/add-and-search-word-data-structure-design/

---

### Coin Change
https://leetcode.com/problems/coin-change/


```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {

        if (amount == 0)
            return 0;

        int* dp = new int[amount + 1];

        for(int i=0; i<=amount; i++)
            dp[i] = -1;

        for(auto coin: coins){
            if (coin <= amount)
              dp[coin] = 1;
        }

        // for(int i=0; i<=amount; i++)
        //     cout<< dp[i] << " ";
        // cout<< endl;

        for(int i=2; i<=amount;i++){
            int min = 2147483647;

            if (dp[i]>0)
                min = dp[i];

            for(int j=1; j<i;j++){
                if(dp[i-j] > 0 && dp[j]>0 && dp[i-j] + dp[j] < min)
                    min = dp[i-j] + dp[j];
            }
            dp[i] = (min == 2147483647)? dp[i] : min;
        }

        // for(int i=0; i<=amount; i++)
        //     cout<< dp[i] << " ";
        // cout<< endl;

        return dp[amount];

        delete[] dp;
    }
};
```
-> time exceed

---
### Jump Game
https://leetcode.com/problems/jump-game/

진짜 그리디 너무어렵다
멍청하게 리스트쓰고 청크만들고 뭐 했는데 다필요없었음

```c++
/*
i에서 j로 바로 점프가 가능하면
i에서 j-1로도 바로 점프가 가능하기 때문에

last index에 접근가능한애를 마지막에서부터 차례로 거꾸로 가주면 됨..
greedy
*/
class Solution {
public:
	bool canJump(vector<int>& nums) {
        int n = nums.size()-1;
        for(int i=n-1;i>=0;i--){
            if(i+nums[i]>=n)
                n = i;
        }
        return n==0;
	}
};
```


---

### Permutation Sequence
https://leetcode.com/problems/permutation-sequence/


```c++
class Solution {
public:
    int f(int n){
        if(n==1 || n==0)
            return 1;

        return n*f(n-1);
    }

    string getPermutation(int n, int k) {
        set<int> s;
        set<int>::iterator iter;

        string ans;
        for(int i=1; i<=n;i++){

            int m = (k-1) / f(n-i) + 1;

            k -= (m-1) * f(n-i);

            iter = s.find(m);

            // 만일 m보다 같거나 작은 수가 이미 s 안에 있으면 그 개수만큼 m을 더해줘야함.
            for(int j=1; j<=m; j++){
                m += s.count(j);
            }

            // cout<< "iter "<<i<<": "<<m<<endl;
            s.insert(m);
            ans += to_string(m);

        }

        return ans;

    }
};

```


---

### Add and Search Word
https://leetcode.com/problems/add-and-search-word-data-structure-design/

trie를 쓸 수 있었던 재밌는 문제.

문자열 찾기 관련한 알고리즘이 많이 있는데,

KMP 등도 매우 매력적인 알고리즘이니 공부하면 좋을 것 같다.

string을 const char*로 바꾸고싶다면 `변수.c_str()`를 이용하자.

```c++
class trie {
public:
    bool is_terminal;
    trie* leaf[26];

    trie(): is_terminal(false) {
        memset(leaf, 0, sizeof(leaf));
    }

    ~trie() {
        for (int i = 0; i < 26; i++) {
            if (leaf[i])
                delete leaf[i];
        }
    }

    void insert(const char* key) {
        if (*key == 0)
            is_terminal = true;

        else {
            if (leaf[*key - 'a'] == 0) {
                leaf[*key - 'a'] = new trie();
            }
            leaf[*key - 'a']->insert(key + 1);
        }
    }

    bool search(const char* key) {
        if (*key == 0)
            if (is_terminal)
                return true;
            else
                return false;

        if (*key == '.') {
            bool check = false;
            for (int i = 0; i < 26; i++) {
                if (leaf[i])
                    check |= leaf[i]->search(key + 1);
            }

            return check;
        }


        if (leaf[*key - 'a'] == 0)
            return false;

        return leaf[*key - 'a']->search(key + 1);
    }
};

class WordDictionary {
private:
    trie* root;

public:
    /** Initialize your data structure here. */
    WordDictionary() {
        root = new trie();
    }

    /** Adds a word into the data structure. */
    void addWord(string word) {
        this->root->insert(word.c_str());
    }

    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
    bool search(string word) {
        return root->search(word.c_str());
    }
};
```
