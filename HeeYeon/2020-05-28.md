## 백준

### 17070. 파이프 옮기기 1
(주소)https://www.acmicpc.net/problem/17070


#### 풀이 해설:



```c++
#include<iostream>
#include<algorithm>
#include<queue>

using namespace std;

int N, num=0;
int map[16][16];
int dir1[4][2]={{0,1},{0,1},{0,1},{1,1}};  //가로
int dir2[4][2]={{1,0},{1,0},{1,0},{1,1}};  //세로
int dir3[6][2]={{1,1},{0,1},{1,1},{1,0},{1,1},{1,1}}; //대각선
queue<pair<int, int>> q1;
queue<pair<int, int>> q2;

void bfs(){
    while(!q1.empty() || !q2.empty()){
        int x1=q1.front().first;
        int y1=q1.front().second;
        int x2=q2.front().first;
        int y2=q2.front().second;
        
        if(x2==N-1 && y2==N-1){
            num++;
        }
        
        q1.pop();
        q2.pop();
        
        if(x1==x2 && y1<y2){  // 가로 형태일 경우
            for(int i=0;i<2;i++){
                int xx1=x1+dir1[i*2][0];
                int yy1=y1+dir1[i*2][1];
                int xx2=x2+dir1[i*2+1][0];
                int yy2=y2+dir1[i*2+1][1];
                if(0<=xx2 && xx2<N && 0<=yy2 && yy2<N){
                    if(i==0){
                        if(map[xx2][yy2]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                    if(i==1){
                        if(map[xx2][yy2]==0 && map[xx2-1][yy2]==0 && map[xx2][yy2-1]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                }
            }
        }
        else if(x1<x2 && y1==y2){  // 세로 형태일 경우
            for(int i=0;i<2;i++){
                int xx1=x1+dir2[i*2][0];
                int yy1=y1+dir2[i*2][1];
                int xx2=x2+dir2[i*2+1][0];
                int yy2=y2+dir2[i*2+1][1];
                if(0<=xx2 && xx2<N && 0<=yy2 && yy2<N){
                    if(i==0){
                        if(map[xx2][yy2]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                    if(i==1){
                        if(map[xx2][yy2]==0 && map[xx2-1][yy2]==0 && map[xx2][yy2-1]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                }
            }
        }
        else if(x1<x2 && y1<y2){  // 대각선 형태일 
            for(int i=0;i<3;i++){
                int xx1=x1+dir3[i*2][0];
                int yy1=y1+dir3[i*2][1];
                int xx2=x2+dir3[i*2+1][0];
                int yy2=y2+dir3[i*2+1][1];
                if(0<=xx2 && xx2<N && 0<=yy2 && yy2<N){
                    if(i==0 || i==1){
                        if(map[xx2][yy2]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                    if(i==2){
                        if(map[xx2][yy2]==0 && map[xx2-1][yy2]==0 && map[xx2][yy2-1]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                }
            }
        }
    }
}

int main(){
    cin>>N;
    for(int i=0;i<N;i++){
        for(int j=0;j<N;j++){
            cin>>map[i][j];
        }
    }
    q1.push({0,0});
    q2.push({0,1});
    bfs();
    cout<<num;
}
```

---


### 14891. 톱니바퀴
(주소)https://www.acmicpc.net/problem/14891


#### 풀이 해설:

 시뮬레이션


```c++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<stdio.h>

using namespace std;

deque<int> dq[4];
int a, K, sum=0, two=1;
int num, dir;
bool visited[4];

void turn(int num, int dir){
    if(dir==1){  // 시계방향 회전
        int end = dq[num].back();
        dq[num].pop_back();
        dq[num].push_front(end);
    }
    else{    // 반시계방향 회전
        int start = dq[num].front();
        dq[num].pop_front();
        dq[num].push_back(start);
    }
}

void turn_check(int num, int dir){
    visited[num]=true;
    if(num-1>=0 && !visited[num-1]){ // 왼쪽 탐색
        if(dq[num][6]!=dq[num-1][2]){
            turn_check(num-1, dir * -1);
        }
    }
    if(num+1<=3 && !visited[num+1]){ // 오른쪽 탐색
        if(dq[num][2]!=dq[num+1][6]){
            turn_check(num+1, dir * -1);
        }
    }
    turn(num, dir);
}

int main(){
    
    for(int i=0;i<4;i++){
        for(int j=0;j<8;j++){
            scanf("%1d", &a);
            dq[i].push_back(a);
        }
    }
    
    cin>>K; // 회전 횟수
    for(int i=0;i<K;i++){
        cin>>num>>dir;
        turn_check(num-1, dir); // dq[4] 였으므로 톱니바퀴 번호는 0~3
        memset(visited, false, sizeof(visited));
    }
    for(int i=0;i<4;i++){
        if(dq[i][0]==1){
            sum+=two;
        }
        two*=2;
    }
    cout<<sum;
}
```

---

