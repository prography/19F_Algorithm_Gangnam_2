## 백준

### 17070. 파이프 옮기기 1
(주소)https://www.acmicpc.net/problem/17070


#### 풀이 해설:



```c++
#include<iostream>
#include<algorithm>
#include<queue>

using namespace std;

int N, num=0;
int map[16][16];
int dir1[4][2]={{0,1},{0,1},{0,1},{1,1}};  //가로
int dir2[4][2]={{1,0},{1,0},{1,0},{1,1}};  //세로
int dir3[6][2]={{1,1},{0,1},{1,1},{1,0},{1,1},{1,1}}; //대각선
queue<pair<int, int>> q1;
queue<pair<int, int>> q2;

void bfs(){
    while(!q1.empty() || !q2.empty()){
        int x1=q1.front().first;
        int y1=q1.front().second;
        int x2=q2.front().first;
        int y2=q2.front().second;
        
        if(x2==N-1 && y2==N-1){
            num++;
        }
        
        q1.pop();
        q2.pop();
        
        if(x1==x2 && y1<y2){  // 가로 형태일 경우
            for(int i=0;i<2;i++){
                int xx1=x1+dir1[i*2][0];
                int yy1=y1+dir1[i*2][1];
                int xx2=x2+dir1[i*2+1][0];
                int yy2=y2+dir1[i*2+1][1];
                if(0<=xx2 && xx2<N && 0<=yy2 && yy2<N){
                    if(i==0){
                        if(map[xx2][yy2]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                    if(i==1){
                        if(map[xx2][yy2]==0 && map[xx2-1][yy2]==0 && map[xx2][yy2-1]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                }
            }
        }
        else if(x1<x2 && y1==y2){  // 세로 형태일 경우
            for(int i=0;i<2;i++){
                int xx1=x1+dir2[i*2][0];
                int yy1=y1+dir2[i*2][1];
                int xx2=x2+dir2[i*2+1][0];
                int yy2=y2+dir2[i*2+1][1];
                if(0<=xx2 && xx2<N && 0<=yy2 && yy2<N){
                    if(i==0){
                        if(map[xx2][yy2]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                    if(i==1){
                        if(map[xx2][yy2]==0 && map[xx2-1][yy2]==0 && map[xx2][yy2-1]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                }
            }
        }
        else if(x1<x2 && y1<y2){  // 대각선 형태일 
            for(int i=0;i<3;i++){
                int xx1=x1+dir3[i*2][0];
                int yy1=y1+dir3[i*2][1];
                int xx2=x2+dir3[i*2+1][0];
                int yy2=y2+dir3[i*2+1][1];
                if(0<=xx2 && xx2<N && 0<=yy2 && yy2<N){
                    if(i==0 || i==1){
                        if(map[xx2][yy2]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                    if(i==2){
                        if(map[xx2][yy2]==0 && map[xx2-1][yy2]==0 && map[xx2][yy2-1]==0){
                            q1.push({xx1,yy1});
                            q2.push({xx2,yy2});
                        }
                    }
                }
            }
        }
    }
}

int main(){
    cin>>N;
    for(int i=0;i<N;i++){
        for(int j=0;j<N;j++){
            cin>>map[i][j];
        }
    }
    q1.push({0,0});
    q2.push({0,1});
    bfs();
    cout<<num;
}
```

---
