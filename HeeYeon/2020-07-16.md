### 139. Word Break
(주소)https://leetcode.com/problems/word-break/

#### 풀이 해설:

문자열 s가 wordDict에 있는 문자열들 조합 (1개 or 그 이상) 으로 만들어질 수 있는지 알아내는 문제.

문자열 s의 각 인덱스마다 dp값 결정 (dp[i] : s의 인덱스 0부터 i까지의 문자열을 만들 수 있는 조합이 존재하는지. 존재하면 1, 존재하지않으면 0)

ex.

s[0]~s[3] 이 "abcd"라면 mp["abcd"] 확인 후 없으면

dp[0] == true && mp["bcd"], dp[1] == true && mp["cd"], dp[2] == true && mp["d"] 를 검사하여 참인게 하나라도 있으면 dp값 1로 설정.


```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        map<string, int> mp;
        int dp[s.size()+1];
        
        for(int i=0;i<=s.size();i++){  // 초기화
            dp[i] = 0;
        }
        
        for(int i=0;i<wordDict.size();i++){
            mp[wordDict[i]]++;
        }
        
        for(int i=0;i<s.size();i++){
            if(mp[s.substr(0,i+1)] > 0) {  // s.substr(0,i+1) : 문자열s 0번째 인덱스에서 i+1개 만큼
                dp[i] = 1;
                continue;
            }
            for(int j=0;j<i;j++){
                if(dp[j] && mp[s.substr(j+1,i-j)] > 0){
                    dp[i]=1;
                    break;
                }
            }
        }
        
        return dp[s.size()-1];
    }
};
```

---


### 134. Gas Station
(주소)https://leetcode.com/problems/gas-station/

#### 풀이 해설:

차가 i-1에서 i로 이동하는데에는 gas[i]를 얻은 뒤, cost[i]를 소모.

그래서 gas[i] - cost[i]를 축적하여 더해나가는 go 가 음수가 되는 순간은 그 지점 >=  인 인덱스에서는 출발할 수 없다는 의미이므로 idx 를 i+1 로 설정.

go를 0으로 초기화 한 뒤 음수였던 go값은 minus에 더해둠.

마지막에 go와 minus를 더해 0보다 작으면 어느위치에서나 출발할 수 없다는 뜻이므로 -1 반환.


```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        
        int idx = 0, go = 0, minus = 0;
        
        for(int i=0;i<cost.size();i++){
            go += gas[i] - cost[i];
            if(go < 0){
                idx = i + 1;
                minus += go;
                go = 0;  // 새 출발, idx 에서 출발하겠다
            }
        }
        if(go + minus >= 0) return idx;
        else return -1;
    }
};
```

---
